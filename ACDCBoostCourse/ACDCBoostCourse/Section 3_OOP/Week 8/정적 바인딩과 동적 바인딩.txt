정적 바인딩의 경우 
포인터 변수는 선언될 때의 클래스를 따라가고

virtual을 사용한 동적 바인딩의 경우
오버라이딩된 메서드가 정확하게 출력된다.
--------------------------------------------------------------------------------------------------------------
Bind는 하나의 묶음으로 묶다라는 뜻이다. C++에서 바인딩이란, 클래스에 묶는 것을 의미한다.

부모 클래스 Base와 상속된 자식 클래스 Derived 가 있고
부모 클래스 내에 func()이라는 메서드가 있고 Derived 클래스에서 func()가 오버라이딩 되어있다.

그리고 두 개의 인스턴스
Base b;
Derived d;
를 생성하였다. 

이제 Base *ptr 이라는 포인터 변수를 만들고 
ptr = &b; 로 한 뒤
ptr→func()를 실행하고
ptr = &d; 로 한 뒤
ptr→func()를 실행하였는데 - (1)

(1)에서 오버라이딩 된 func이 실행되지 않고 Base에 해당하는 func이 실행되게 된다.
C++은 default로 정적 바인딩을 실행하고
정적 바인딩은 컴파일 타임에서 결정이 되므로, ptr이 어떤 객체를 가리키고 있는지 알 수 없기 때문에 
무조건, Base* ptr 이라고 정의하였으므로, Base에 해당하는 func을 실행하게 된다.
즉 정적 바인딩에서는 무조건 ptr이 선언될 때의 클래스로 func이 실행되게 되는 것이다 
(Base에 묶인 것! - 바인딩!)

그러나 func에 virtual이라는 키워드를 작성하게 되면
바인딩이 컴파일 타임에서 유보되고, 런타임에서 바인딩이 진행되게 된다. 
이를 동적 바인딩이라고 하며 
이 경우 런타임에서 어디에 바인딩이 될지 결정되므로 
위의 예시에서 ptr이 d의 주소를 가리킬 때 오버라이딩된 메서드가 정확하게 출력됨을 알 수 있다.